###### inline

因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到调用函数的下一行代码继续执行。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。

而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。

但是宏也有很多的不尽人意的地方。

- 宏不能访问对象的私有成员。

- 宏的定义很容易产生二义性。

- 宏定义的常量在代码区，很多调试器不能够对其调试

- 宏会增大代码的尺寸

我们举个例子：
```c
#define square(x) (x*x)
```
避免这些错误的方法是：给宏的参数都加上括号。
```c
#define square(x) ((x)*(x))
```
 

内联函数和宏很类似，而本质区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈出栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。

 
```c
###### volatile 
```
volatile字面意思是“易变的”。这个关键字来描述一个变量时，意味着给该变量赋值(写入)之后，马上再读取，写入的值与读取的值可能不一样,所以说它“易变的”。这是因为这个变量可能是一个寄存器，直接与外部设备相连，你写入之后，该寄存器也有可能被外部设备的写操作所改变; 或者，该变量被一个中断程序，或另一个进程改变了。volatile 不会被编译器优化影响。

简而言之，volatile关键字用于声明内存映射的易失型变量，这类变量的值随时可能由于某种编译器所不知道的原因(例如，外部设备对其写入)所改变，所以编译器在进行代码优化时不能对其做任何的假设和依赖
